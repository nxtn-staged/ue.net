// Copyright (c) NextTurn. All rights reserved.
// Licensed under the Apache License, Version 2.0.
// See LICENSE.txt in the project root for more information.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.Formatting;
using Unreal;
using Enum = Unreal.Enum;
using Object = Unreal.Object;
using SF = Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SG = NextTurn.UE.Programs.CSharpSyntaxGenerator;

namespace NextTurn.UE.Programs
{
    internal static class CSharpCodeGenerator
    {
        private const string CommentL1 = "// Copyright (c) NextTurn. All rights reserved.";
        private const string CommentL2 = "// Licensed under the Apache License, Version 2.0.";
        private const string CommentL3 = "// See LICENSE.txt in the project root for more information.";
        private const string CommentL4 = "// <auto-generated />";

        private const string ClassFieldName = "__class";
        private const string DelegateFieldName = "__delegate";
        private const string StructFieldName = "__struct";

        private const string ClassFieldSuffix = "__Class";
        private const string PropertyFieldSuffix = "__Property";
        private const string PropertyBackingFieldSuffix = "__Field";
        private const string MethodFieldSuffix = "__Method";
        private const string ParametersSizeFieldSuffix = "__ParametersSize";
        private const string ParameterOffsetFieldSuffix = "__Offset";

        private const string ParametersLocalName = "__parameters";

        private const Accessibility CommonTypeAccessibility = Accessibility.Public;
        private const Accessibility CommonFieldAccessibility = Accessibility.Private;

        private static readonly DeclarationModifiers CommonFieldModifiers = DeclarationModifiers.Static | DeclarationModifiers.ReadOnly;

        private static SyntaxGenerator sg = null!;

        /// <summary>
        /// The <see cref="sbyte"/> type.
        /// </summary>
        private static TypeSyntax sbyteType = null!;

        /// <summary>
        /// The <see cref="byte"/> type.
        /// </summary>
        private static TypeSyntax byteType = null!;

        /// <summary>
        /// The <see cref="short"/> type.
        /// </summary>
        private static TypeSyntax int16Type = null!;

        /// <summary>
        /// The <see cref="ushort"/> type.
        /// </summary>
        private static TypeSyntax uint16Type = null!;

        /// <summary>
        /// The <see cref="int"/> type.
        /// </summary>
        private static TypeSyntax int32Type = null!;

        /// <summary>
        /// The <see cref="uint"/> type.
        /// </summary>
        private static TypeSyntax uint32Type = null!;

        /// <summary>
        /// The <see cref="long"/> type.
        /// </summary>
        private static TypeSyntax int64Type = null!;

        /// <summary>
        /// The <see cref="ulong"/> type.
        /// </summary>
        private static TypeSyntax uint64Type = null!;

        /// <summary>
        /// The <see cref="float"/> type.
        /// </summary>
        private static TypeSyntax singleType = null!;

        /// <summary>
        /// The <see cref="double"/> type.
        /// </summary>
        private static TypeSyntax doubleType = null!;

        /// <summary>
        /// The <see cref="string"/> type.
        /// </summary>
        private static TypeSyntax stringType = null!;

        /// <summary>
        /// The <see langword="nint"/> type.
        /// </summary>
        private static SyntaxNode nintType = null!;

        /// <summary>
        /// The <see cref="byte"/> pointer type.
        /// </summary>
        private static TypeSyntax bytePointerType = null!;

        /// <summary>
        /// The <see langword="global"/> namespace.
        /// </summary>
        private static IdentifierNameSyntax globalNamespace = null!;

        /// <summary>
        /// The <see cref="UE"/> namespace.
        /// </summary>
        private static SyntaxNode internalNamespace = null!;

        /// <summary>
        /// The <see cref="Unreal"/> namespace.
        /// </summary>
        private static SyntaxNode publicNamespace = null!;

        /// <summary>
        /// The <see cref="NativeBoolean"/> type.
        /// </summary>
        private static SyntaxNode nativeBooleanType = null!;

        /// <summary>
        /// The <see cref="Name"/> type.
        /// </summary>
        private static SyntaxNode nameType = null!;

        /// <summary>
        /// The <see cref="CommentL1"/> type.
        /// </summary>
        private static SyntaxNode textType = null!;

        /// <summary>
        /// The <see cref="Object"/> type.
        /// </summary>
        private static SyntaxNode unrealObjectType = null!;

        /// <summary>
        /// The <see cref="Class"/> type.
        /// </summary>
        private static SyntaxNode unrealClassType = null!;

        /// <summary>
        /// The <see cref="Struct"/> type.
        /// </summary>
        private static SyntaxNode unrealStructType = null!;

        /// <summary>
        /// The <see cref="Property"/> type.
        /// </summary>
        private static SyntaxNode unrealPropertyType = null!;

        /// <summary>
        /// The <see cref="Method"/> type.
        /// </summary>
        private static SyntaxNode unrealMethodType = null!;

        /// <summary>
        /// The <see cref="ScriptDelegate"/> type.
        /// </summary>
        private static SyntaxNode scriptDelegateType = null!;

        /// <summary>
        /// The <see cref="IDynamicDelegate"/> type.
        /// </summary>
        private static SyntaxNode idynamicDelegateType = null!;

        /// <summary>
        /// The <see cref="DynamicMulticastDelegate"/> type.
        /// </summary>
        private static SyntaxNode dynamicMulticastDelegateType = null!;

        /// <summary>
        /// The <see cref="BooleanMarshaler"/> type.
        /// </summary>
        private static SyntaxNode booleanMarshalerType = null!;

        /// <summary>
        /// The <see cref="ObjectMarshaler"/> type.
        /// </summary>
        private static SyntaxNode objectMarshalerType = null!;

        /// <summary>
        /// The <see cref="StringMarshaler"/> type.
        /// </summary>
        private static SyntaxNode stringMarshalerType = null!;

        /// <summary>
        /// The <see cref="TextMarshaler"/> type.
        /// </summary>
        private static SyntaxNode textMarshalerType = null!;

        /// <summary>
        /// The <see cref="Package.Any"/> property.
        /// </summary>
        private static SyntaxNode packageAnyProperty = null!;

        /// <summary>
        /// The <see cref="Object.Find{T}(Object, string)"/> method.
        /// </summary>
        private static SyntaxNode objectFindClassMethod = null!;

        /// <summary>
        /// The <see cref="BooleanMarshaler.ToManaged(IntPtr, int)"/> method.
        /// </summary>
        private static SyntaxNode booleanMarshalerToManagedMethod = null!;

        /// <summary>
        /// The <see cref="BooleanMarshaler.ToNative(IntPtr, int, bool)"/> method.
        /// </summary>
        private static SyntaxNode booleanMarshalerToNativeMethod = null!;

        /// <summary>
        /// The <see cref="ObjectMarshaler.ToManaged(IntPtr)"/> method.
        /// </summary>
        private static SyntaxNode objectMarshalerToManagedMethod = null!;

        /// <summary>
        /// The <see cref="ObjectMarshaler.ToNative(IntPtr, Object)"/> method.
        /// </summary>
        private static SyntaxNode objectMarshalerToNativeMethod = null!;

        /// <summary>
        /// The <see cref="StringMarshaler.ToManaged(ScriptArray*)"/> method.
        /// </summary>
        private static SyntaxNode stringMarshalerToManagedMethod = null!;

        /// <summary>
        /// The <see cref="StringMarshaler.ToNative(ScriptArray*, string)"/> method.
        /// </summary>
        private static SyntaxNode stringMarshalerToNativeMethod = null!;

        /// <summary>
        /// The <see cref="TextMarshaler.ToManaged(IntPtr, int)"/> method.
        /// </summary>
        private static SyntaxNode textMarshalerToManagedMethod = null!;

        /// <summary>
        /// The <see cref="TextMarshaler.ToNative(IntPtr, int, Text)"/> method.
        /// </summary>
        private static SyntaxNode textMarshalerToNativeMethod = null!;

        private static List<SyntaxNode> declarations = null!;

        private static Dictionary<Class, SyntaxNode> classes = null!;
        private static Dictionary<Method, SyntaxNode> delegates = null!;
        private static Dictionary<Enum, SyntaxNode> enums = null!;
        private static Dictionary<Class, SyntaxNode> interfaces = null!;
        private static Dictionary<Method, SyntaxNode> multicastDelegates = null!;
        private static Dictionary<Struct, SyntaxNode> structs = null!;

        [UnmanagedCallersOnly]
        internal static void AddClass(IntPtr @class)
        {
            _ = ExportClass(Object.Create<Class>(@class));
        }

        private static SyntaxNode ExportClass(Class unrealClass)
        {
            if (classes.TryGetValue(unrealClass, out SyntaxNode? classType))
            {
                return classType;
            }

            SyntaxNode namespaceSyntax = publicNamespace;
            string typeName = GetName(unrealClass);
            classes[unrealClass] = classType = sg.QualifiedName(namespaceSyntax, sg.IdentifierName(typeName));

            SyntaxNode classField = sg.FieldDeclaration(
                ClassFieldName,
                unrealClassType,
                CommonFieldAccessibility,
                CommonFieldModifiers,
                sg.InvocationExpression(
                    sg.QualifiedName(
                        unrealObjectType,
                        sg.GenericName(
                            nameof(Object.Find),
                            unrealClassType)),
                    packageAnyProperty,
                    sg.LiteralExpression(typeName)));

            foreach (ImplementedInterface implementedInterface in unrealClass.Interfaces)
            {
                SyntaxNode interfaceType = ExportInterface(implementedInterface.InterfaceClass);
            }

            declarations.Add(
                sg.NamespaceDeclaration(
                    namespaceSyntax,
                    sg.ClassDeclaration(
                        typeName,
                        null,
                        CommonTypeAccessibility,
                        default,
                        unrealObjectType,
                        null,
                        Singleton.Enumerable(classField).Concat(ExportProperties(unrealClass, classType)).Concat(ExportMethods(unrealClass, classType)))));

            return classType;
        }

        private static SyntaxNode ExportDelegate(DelegateMethod signatureMethod)
        {
            if (delegates.TryGetValue(signatureMethod, out SyntaxNode? delegateType))
            {
                return delegateType;
            }

            SyntaxNode namespaceSyntax = publicNamespace;
            string typeName = signatureMethod.Name.ToString()[..^DelegateMethod.NameSuffix.Length];
            delegates[signatureMethod] = delegateType = sg.QualifiedName(namespaceSyntax, sg.IdentifierName(typeName));

            SyntaxNode delegateFieldExpression = sg.MemberAccessExpression(sg.ThisExpression(), DelegateFieldName);

            SyntaxNode delegateField = sg.FieldDeclaration(
                    DelegateFieldName,
                    scriptDelegateType,
                    CommonFieldAccessibility,
                    DeclarationModifiers.ReadOnly,
                    null);

            SyntaxNode methodNameProperty = sg.PropertyDeclaration(
                nameof(IDynamicDelegate.MethodName),
                nameType,
                Accessibility.Public,
                default,
                Singleton.Enumerable(
                    sg.ReturnStatement(
                        sg.MemberAccessExpression(
                            delegateFieldExpression,
                            nameof(IDynamicDelegate.MethodName)))));

            SyntaxNode targetProperty = sg.PropertyDeclaration(
                nameof(IDynamicDelegate.Target),
                unrealObjectType,
                Accessibility.Public,
                default,
                Singleton.Enumerable(
                    sg.ReturnStatement(
                        sg.MemberAccessExpression(
                            delegateFieldExpression,
                            nameof(IDynamicDelegate.Target)))));

            SyntaxNode[] members = new[]
            {
                delegateField,
                methodNameProperty,
                targetProperty,
            };

            declarations.Add(
                sg.NamespaceDeclaration(
                    namespaceSyntax,
                    sg.StructDeclaration(
                        typeName,
                        null,
                        CommonTypeAccessibility,
                        default,
                        Singleton.Enumerable(idynamicDelegateType),
                        members)));

            return delegateType;
        }

        private static SyntaxNode ExportEnum(Enum unrealEnum, SyntaxNode underlyingType)
        {
            if (enums.TryGetValue(unrealEnum, out SyntaxNode? enumType))
            {
                return enumType;
            }

            SyntaxNode namespaceSyntax = publicNamespace;
            string typeName = GetName(unrealEnum);
            enums[unrealEnum] = enumType = sg.QualifiedName(namespaceSyntax, sg.IdentifierName(typeName));

            IEnumerable<KeyValuePair<Name, long>> namesAndValues = unrealEnum.NamesAndValues;

            List<SyntaxNode> members = new List<SyntaxNode>();

            bool hasMax = false;
            foreach ((Name nameHandle, long value) in namesAndValues)
            {
                Debug.Assert(!hasMax);

                string name = nameHandle.ToString();
                string commonPrefix = unrealEnum.Name.ToString();

                if (!name.StartsWith(commonPrefix, "::"))
                {
                    members.Add(sg.EnumMember(name, sg.LiteralExpression(value)));
                    continue;
                }

                Debug.Assert(name.StartsWith(commonPrefix, "::"));

                if (name.EndsWith("MAX"))
                {
                    hasMax = true;
                    continue;
                }

                members.Add(sg.EnumMember(name[commonPrefix.Length..], sg.LiteralExpression(value)));
            }

            declarations.Add(
                sg.NamespaceDeclaration(
                    namespaceSyntax,
                    sg.EnumDeclaration(
                        typeName,
                        CommonTypeAccessibility,
                        default,
                        members)));

            return enumType;
        }

        private static SyntaxNode ExportInterface(Class unrealClass)
        {
            if (interfaces.TryGetValue(unrealClass, out SyntaxNode? interfaceType))
            {
                return interfaceType;
            }

            SyntaxNode namespaceSyntax = publicNamespace;
            string typeName = "I" + GetName(unrealClass);
            interfaces[unrealClass] = interfaceType = sg.QualifiedName(namespaceSyntax, sg.IdentifierName(typeName));

            declarations.Add(
                sg.NamespaceDeclaration(
                    namespaceSyntax,
                    sg.InterfaceDeclaration(
                        typeName,
                        null,
                        CommonTypeAccessibility,
                        null,
                        ExportProperties(unrealClass, interfaceType, true).Concat(ExportMethods(unrealClass, interfaceType, true)))));

            return interfaceType;
        }

        private static IEnumerable<SyntaxNode> ExportMethods(Class unrealClass, SyntaxNode typeSyntax, bool isInterface = false)
        {
            foreach (Method unrealMethod in unrealClass.EnumerateMembers<Method>())
            {
                string methodName = unrealMethod.Name.ToString();
                string methodFieldName = methodName + MethodFieldSuffix;
                SyntaxNode methodFieldExpression = sg.QualifiedName(typeSyntax, sg.IdentifierName(methodFieldName));

                string parametersSizeFieldName = unrealMethod.Name + ParametersSizeFieldSuffix;
                SyntaxNode parametersSizeFieldExpression = sg.QualifiedName(typeSyntax, sg.IdentifierName(parametersSizeFieldName));

                if (!isInterface)
                {
                    yield return sg.FieldDeclaration(
                        methodFieldName,
                        unrealMethodType,
                        CommonFieldAccessibility,
                        CommonFieldModifiers,
                        sg.InvocationExpression(
                            sg.MemberAccessExpression(
                                sg.QualifiedName(
                                    typeSyntax,
                                    sg.IdentifierName(ClassFieldName)),
                                nameof(Class.FindMethod)),
                            sg.LiteralExpression(unrealMethod.Name.ToString())));

                    yield return sg.FieldDeclaration(
                        parametersSizeFieldName,
                        int32Type,
                        CommonFieldAccessibility,
                        CommonFieldModifiers,
                        sg.MemberAccessExpression(
                            methodFieldExpression,
                            nameof(Method.ParametersSize)));
                }

                Accessibility methodAccessibility =
                    unrealMethod.IsFamily ? Accessibility.Protected :
                    unrealMethod.IsPublic ? Accessibility.Public :
                    Accessibility.NotApplicable;

                List<SyntaxNode> statements = new List<SyntaxNode>();

                SyntaxNode parametersLocalExpression = sg.IdentifierName(ParametersLocalName);

                statements.Add(
                    sg.LocalDeclarationStatement(
                        bytePointerType,
                        ParametersLocalName,
                        SG.StackAllocArrayCreationExpression(
                            byteType,
                            (QualifiedNameSyntax)parametersSizeFieldExpression)));

                List<Property> unrealParameters = new List<Property>();
                List<SyntaxNode> parameters = new List<SyntaxNode>();
                List<SyntaxNode> parameterOffsetFieldExpressions = new List<SyntaxNode>();
                SyntaxNode? returnType = null;
                foreach (Property unrealParameter in unrealMethod.ParameterProperties)
                {
                    SyntaxNode parameterType = GetPropertyType(unrealParameter);
                    if (parameterType is null) continue;

                    if (unrealParameter.IsReturnParameter)
                    {
                        returnType = parameterType;
                        continue;
                    }

                    // | C++              | C#           |
                    // | ---------------- | ------------ |
                    // | out              | out          |
                    // | out ref          | ref          |
                    // | out ref readonly | ref readonly |
                    RefKind refKind = RefKind.None;
                    if (unrealParameter.HasAnyFlags(PropertyFlags.OutParameter))
                    {
                        refKind = RefKind.Ref;

                        if (!unrealParameter.HasAnyFlags(PropertyFlags.ByReferenceParameter))
                        {
                            refKind = RefKind.Out;
                        }
                        else if (unrealParameter.HasAnyFlags(PropertyFlags.ReadOnlyParameter))
                        {
                            refKind = RefKind.In;
                        }
                    }

                    string parameterName = GetName(unrealParameter);
                    SyntaxNode parameterExpression = sg.IdentifierName(parameterName);

                    string parameterOffsetFieldName = methodName + "__" + parameterName + ParameterOffsetFieldSuffix;
                    SyntaxNode parameterOffsetFieldExpression = sg.QualifiedName(typeSyntax, sg.IdentifierName(parameterOffsetFieldName));

                    if (!isInterface)
                    {
                        yield return sg.FieldDeclaration(
                            parameterOffsetFieldName,
                            int32Type,
                            CommonFieldAccessibility,
                            CommonFieldModifiers,
                            sg.MemberAccessExpression(
                                sg.InvocationExpression(
                                    sg.MemberAccessExpression(
                                        methodFieldExpression,
                                        sg.GenericName(
                                            nameof(CompoundMember.FindMember),
                                            unrealPropertyType)),
                                    sg.LiteralExpression(parameterName)),
                                nameof(Property.Offset)));
                    }

                    unrealParameters.Add(unrealParameter);
                    parameters.Add(sg.ParameterDeclaration(parameterName, parameterType, null, refKind));
                    parameterOffsetFieldExpressions.Add(parameterOffsetFieldExpression);

                    if (!unrealParameter.HasAnyFlags(PropertyFlags.OutParameter) ||
                        unrealParameter.HasAnyFlags(PropertyFlags.ByReferenceParameter))
                    {
                        statements.Add(
                            sg.ExpressionStatement(
                                sg.InvocationExpression(
                                    GetPropertyMarshalerToNativeMethod(unrealParameter),
                                    sg.AddExpression(
                                        parametersLocalExpression,
                                        parameterOffsetFieldExpression),
                                    sg.LiteralExpression(0),
                                    parameterExpression)));
                    }
                }

                statements.Add(
                    sg.ExpressionStatement(
                        sg.InvocationExpression(
                            sg.MemberAccessExpression(
                                methodFieldExpression,
                                nameof(Method.Invoke)),
                            sg.ThisExpression(),
                            parametersLocalExpression)));

                for (int i = 0; i < unrealParameters.Count; i++)
                {
                    Property unrealParameter = unrealParameters[i];
                    SyntaxNode parameter = parameters[i];
                    SyntaxNode parameterOffsetFieldExpression = parameterOffsetFieldExpressions[i];

                    if (parameter is null) continue;

                    if (unrealParameter.HasAnyFlags(PropertyFlags.OutParameter) && !unrealParameter.IsReturnParameter)
                    {
                        statements.Add(
                            sg.ExpressionStatement(
                                sg.InvocationExpression(
                                    GetPropertyMarshalerToManagedMethod(unrealParameter),
                                    sg.AddExpression(
                                        parametersLocalExpression,
                                        parameterOffsetFieldExpression),
                                    sg.LiteralExpression(0))));
                    }
                }

                yield return sg.MethodDeclaration(
                    GetName(unrealMethod),
                    parameters,
                    null,
                    returnType,
                    methodAccessibility,
                    unrealMethod.IsStatic ? DeclarationModifiers.Static : default,
                    statements);
            }
        }

        private static SyntaxNode ExportMulticastDelegate(DelegateMethod signatureMethod)
        {
            if (multicastDelegates.TryGetValue(signatureMethod, out SyntaxNode? delegateType))
            {
                return delegateType;
            }

            SyntaxNode namespaceSyntax = publicNamespace;
            string typeName = signatureMethod.Name.ToString()[..^DelegateMethod.NameSuffix.Length];
            multicastDelegates[signatureMethod] = delegateType = sg.QualifiedName(namespaceSyntax, sg.IdentifierName(typeName));

            declarations.Add(
                sg.NamespaceDeclaration(
                    namespaceSyntax,
                    sg.ClassDeclaration(
                        typeName,
                        null,
                        CommonTypeAccessibility,
                        default,
                        dynamicMulticastDelegateType,
                        null,
                        null)));

            return delegateType;
        }

        private static IEnumerable<SyntaxNode> ExportProperties(Class unrealClass, SyntaxNode typeSyntax, bool isInterface = false)
        {
            foreach (Property unrealProperty in unrealClass.EnumerateProperties<Property>())
            {
                string propertyName = GetName(unrealProperty);

                string propertyFieldName = propertyName + PropertyFieldSuffix;
                SyntaxNode propertyFieldExpression = sg.QualifiedName(typeSyntax, sg.IdentifierName(propertyFieldName));

                if (!isInterface)
                {
                    yield return sg.FieldDeclaration(
                        propertyFieldName,
                        unrealPropertyType,
                        CommonFieldAccessibility,
                        CommonFieldModifiers,
                        sg.InvocationExpression(
                            sg.MemberAccessExpression(
                                sg.QualifiedName(
                                    typeSyntax,
                                    sg.IdentifierName(ClassFieldName)),
                                sg.GenericName(
                                    nameof(CompoundMember.FindMember),
                                    unrealPropertyType)),
                            sg.LiteralExpression(propertyName)));
                }

                SyntaxNode propertyType = GetPropertyType(unrealProperty);
                if (propertyType is null) continue;

                if (unrealProperty.ArrayLength == 1)
                {
                    yield return sg.PropertyDeclaration(
                        propertyName,
                        propertyType,
                        Accessibility.Public,
                        default,
                        Singleton.Enumerable(
                            sg.ReturnStatement(
                                sg.InvocationExpression(
                                    sg.MemberAccessExpression(
                                        propertyFieldExpression,
                                        nameof(Property.GetValue)),
                                    sg.LiteralExpression(0)))),
                        Singleton.Enumerable(
                            sg.InvocationExpression(
                                sg.MemberAccessExpression(
                                    propertyFieldExpression,
                                    nameof(Property.SetValue)),
                                sg.IdentifierName("value"),
                                sg.LiteralExpression(0))));
                }
            }
        }

        private static SyntaxNode ExportStruct(StructProperty structProperty)
        {
            Struct unrealStruct = structProperty.MetaStruct;

            if (structs.TryGetValue(unrealStruct, out SyntaxNode? structType))
            {
                return structType;
            }

            SyntaxNode namespaceSyntax = publicNamespace;
            string typeName = GetName(unrealStruct);
            structs[unrealStruct] = structType = sg.QualifiedName(namespaceSyntax, sg.IdentifierName(typeName));

            SyntaxNode structField = sg.FieldDeclaration(
                StructFieldName,
                unrealStructType,
                CommonFieldAccessibility,
                CommonFieldModifiers,
                sg.InvocationExpression(
                    sg.QualifiedName(
                        unrealObjectType,
                        sg.GenericName(
                            nameof(Object.Find),
                            unrealStructType)),
                    packageAnyProperty,
                    sg.LiteralExpression(typeName)));

            IEnumerable<SyntaxNode> ExportProperties()
            {
                foreach (Property unrealProperty in unrealStruct.EnumerateProperties<Property>())
                {
                    string propertyName = GetName(unrealProperty);

                    string propertyFieldName = propertyName + PropertyFieldSuffix;
                    SyntaxNode propertyFieldExpression = sg.QualifiedName(structType, sg.IdentifierName(propertyFieldName));

                    yield return sg.FieldDeclaration(
                        propertyFieldName,
                        unrealPropertyType,
                        CommonFieldAccessibility,
                        CommonFieldModifiers,
                        sg.InvocationExpression(
                            sg.MemberAccessExpression(
                                propertyFieldExpression,
                                sg.GenericName(
                                    nameof(CompoundMember.FindMember),
                                    unrealPropertyType)),
                            sg.LiteralExpression(propertyName)));

                    SyntaxNode propertyType = GetPropertyType(unrealProperty);
                    if (propertyType is null) continue;

                    if (structProperty.HasAnyFlags(PropertyFlags.Trivial))
                    {
                        string backingFieldName = propertyName + PropertyBackingFieldSuffix;
                        SyntaxNode backingFieldExpression = sg.MemberAccessExpression(sg.ThisExpression(), backingFieldName);

                        if (unrealProperty.ArrayLength == 1)
                        {
                            yield return sg.PropertyDeclaration(
                                propertyName,
                                propertyType,
                                Accessibility.Public,
                                default,
                                Singleton.Enumerable(
                                    sg.ReturnStatement(backingFieldExpression)),
                                Singleton.Enumerable(
                                    sg.AssignmentStatement(backingFieldExpression, sg.IdentifierName("value"))));
                        }
                    }
                }
            }

            declarations.Add(
                sg.NamespaceDeclaration(
                    namespaceSyntax,
                    sg.StructDeclaration(
                        typeName,
                        null,
                        CommonTypeAccessibility,
                        default,
                        null,
                        Singleton.Enumerable(structField).Concat(ExportProperties()))));

            return structType;
        }

        [UnmanagedCallersOnly]
        internal static void FinishExport()
        {
            GenerateEntryPoint();

            SyntaxTriviaList header = SF.TriviaList(
                SF.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, CommentL1),
                SF.EndOfLine(Environment.NewLine),
                SF.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, CommentL2),
                SF.EndOfLine(Environment.NewLine),
                SF.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, CommentL3),
                SF.EndOfLine(Environment.NewLine),
                SF.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, CommentL4),
                SF.EndOfLine(Environment.NewLine),
                SF.EndOfLine(Environment.NewLine));

            using AdhocWorkspace workspace = new AdhocWorkspace();
            foreach (SyntaxNode declaration in declarations)
            {
                SyntaxNode compilationUnit = sg.CompilationUnit(declaration).WithLeadingTrivia(header);
                compilationUnit = Formatter.Format(compilationUnit, workspace);

                using StreamWriter file = new StreamWriter($@"C:\Users\Liim\Documents\Unreal Projects\MyProject\Plugins\UE.NET\__Generated__\{((BaseTypeDeclarationSyntax)((NamespaceDeclarationSyntax)declaration).Members.First()).Identifier.ValueText}.cs");
                compilationUnit.WriteTo(file);
            }

            throw new Exception();
        }

        private static void GenerateEntryPoint()
        {
            SyntaxNode classesType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Classes)));
            SyntaxNode getClassMethod = sg.QualifiedName(classesType, sg.IdentifierName(nameof(Classes.GetClass)));
            SyntaxNode registerMethod = sg.QualifiedName(classesType, sg.IdentifierName(nameof(Classes.Register)));
            SyntaxNode unregisterMethod = sg.QualifiedName(classesType, sg.IdentifierName(nameof(Classes.Unregister)));

            SyntaxNode findObjectMethod = sg.QualifiedName(
                sg.QualifiedName(
                    sg.QualifiedName(
                        publicNamespace,
                        sg.IdentifierName(nameof(Class))),
                    sg.IdentifierName(nameof(Class.NativeMethods))),
                sg.IdentifierName(nameof(Class.NativeMethods.FindObject)));

            const string scriptClassesTypeName = "ScriptClasses";
            SyntaxNode scriptClassesType = SF.AliasQualifiedName(globalNamespace, (IdentifierNameSyntax)sg.IdentifierName(scriptClassesTypeName));

            List<SyntaxNode> classFields = new List<SyntaxNode>(classes.Count);
            List<SyntaxNode> registerAllStatements = new List<SyntaxNode>(classes.Count);
            List<SyntaxNode> unregisterAllStatements = new List<SyntaxNode>(classes.Count);

            foreach ((Class unrealClass, SyntaxNode classType) in classes)
            {
                string classFieldName = GetName(unrealClass) + ClassFieldSuffix;
                SyntaxNode classFieldExpression = sg.QualifiedName(scriptClassesType, sg.IdentifierName(classFieldName));

                classFields.Add(
                    sg.FieldDeclaration(
                        classFieldName,
                        nintType,
                        CommonFieldAccessibility,
                        CommonFieldModifiers,
                        sg.InvocationExpression(
                            findObjectMethod,
                            sg.InvocationExpression(
                                getClassMethod,
                                sg.TypeOfExpression(classesType)),
                            sg.LiteralExpression(unrealClass.GetPathName()))));

                SyntaxNode typeOfClass = sg.TypeOfExpression(classType);

                registerAllStatements.Add(
                    sg.ExpressionStatement(
                        sg.InvocationExpression(
                            registerMethod,
                            classFieldExpression,
                            typeOfClass)));

                unregisterAllStatements.Add(
                    sg.ExpressionStatement(
                        sg.InvocationExpression(
                            unregisterMethod,
                            classFieldExpression,
                            typeOfClass)));
            }

            SyntaxNode[] entryPointMembers = new[]
            {
                sg.MethodDeclaration(
                    "Load",
                    null,
                    null,
                    null,
                    Accessibility.Internal,
                    DeclarationModifiers.Static,
                    Singleton.Enumerable(
                        sg.ExpressionStatement(
                            sg.InvocationExpression(
                                sg.QualifiedName(
                                    scriptClassesType,
                                    sg.IdentifierName("Register")))))),
                sg.MethodDeclaration(
                    "Unload",
                    null,
                    null,
                    null,
                    Accessibility.Internal,
                    DeclarationModifiers.Static,
                    Singleton.Enumerable(
                        sg.ExpressionStatement(
                            sg.InvocationExpression(
                                sg.QualifiedName(
                                    scriptClassesType,
                                    sg.IdentifierName("Unregister")))))),
            };

            declarations.Add(
                sg.ClassDeclaration(
                    "EntryPoint",
                    null,
                    Accessibility.Internal,
                    DeclarationModifiers.Static,
                    null,
                    null,
                    entryPointMembers));

            SyntaxNode[] scriptClassesMethods = new[]
            {
                sg.MethodDeclaration(
                    "Register",
                    null,
                    null,
                    null,
                    Accessibility.Internal,
                    DeclarationModifiers.Static,
                    registerAllStatements),
                sg.MethodDeclaration(
                    "Unregister",
                    null,
                    null,
                    null,
                    Accessibility.Internal,
                    DeclarationModifiers.Static,
                    unregisterAllStatements),
            };

            declarations.Add(
                sg.ClassDeclaration(
                    scriptClassesTypeName,
                    null,
                    Accessibility.Internal,
                    DeclarationModifiers.Static,
                    null,
                    null,
                    classFields.Concat(scriptClassesMethods)));
        }

        private static string GetName(Member member) => member.Name.ToString();

        private static string GetName(Property property) => property.Name.ToString();

        private static SyntaxNode GetPropertyMarshalerToManagedMethod(Property unrealProperty) => unrealProperty switch
        {
            NumericProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            EnumProperty enumProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(enumProperty.UnderlyingProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            BooleanProperty => booleanMarshalerToManagedMethod,

            NameProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        nameType)),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            StringProperty => stringMarshalerToManagedMethod,
            TextProperty => textMarshalerToManagedMethod,

            StructProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            ObjectPropertyBase objectPropertyBase => objectPropertyBase switch
            {
                ObjectProperty => objectMarshalerToManagedMethod,

                WeakObjectProperty or
                LazyObjectProperty or
                SoftObjectProperty => sg.QualifiedName(
                    sg.QualifiedName(
                        internalNamespace,
                        sg.GenericName(
                            nameof(TrivialMarshaler<nint>),
                            GetPropertyType(unrealProperty))),
                    sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

                _ => throw new NotImplementedException(),
            },

            InterfaceProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            ArrayProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            MapProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            SetProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            DelegateProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            MulticastDelegateProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToManaged))),

            PropertyPathProperty => null!,

            _ => throw new NotImplementedException(),
        };

        private static SyntaxNode GetPropertyMarshalerToNativeMethod(Property unrealProperty) => unrealProperty switch
        {
            NumericProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            EnumProperty enumProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(enumProperty.UnderlyingProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            BooleanProperty => booleanMarshalerToNativeMethod,

            NameProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        nameType)),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            StringProperty => stringMarshalerToNativeMethod,
            TextProperty => textMarshalerToNativeMethod,

            StructProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            ObjectPropertyBase objectPropertyBase => objectPropertyBase switch
            {
                ObjectProperty => objectMarshalerToNativeMethod,

                WeakObjectProperty or
                LazyObjectProperty or
                SoftObjectProperty => sg.QualifiedName(
                    sg.QualifiedName(
                        internalNamespace,
                        sg.GenericName(
                            nameof(TrivialMarshaler<nint>),
                            GetPropertyType(unrealProperty))),
                    sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

                _ => throw new NotImplementedException(),
            },

            InterfaceProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            ArrayProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            MapProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            SetProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            DelegateProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            MulticastDelegateProperty => sg.QualifiedName(
                sg.QualifiedName(
                    internalNamespace,
                    sg.GenericName(
                        nameof(TrivialMarshaler<nint>),
                        GetPropertyType(unrealProperty))),
                sg.IdentifierName(nameof(TrivialMarshaler<nint>.ToNative))),

            PropertyPathProperty => null!,

            _ => throw new NotImplementedException(),
        };

        private static SyntaxNode GetPropertyType(Property unrealProperty) => unrealProperty switch
        {
            NumericProperty numericProperty => numericProperty switch
            {
                SByteProperty => sbyteType,
                ByteProperty byteProperty => byteProperty.MetaEnum is not null ? ExportEnum(byteProperty.MetaEnum, byteType) : byteType,
                Int16Property => int16Type,
                UInt16Property => uint16Type,
                Int32Property => int32Type,
                UInt32Property => uint32Type,
                Int64Property => int64Type,
                UInt64Property => uint64Type,
                SingleProperty => singleType,
                DoubleProperty => doubleType,
                _ => throw new NotImplementedException(),
            },

            EnumProperty enumProperty => ExportEnum(enumProperty.MetaEnum, GetPropertyType(enumProperty.UnderlyingProperty)),

            BooleanProperty => nativeBooleanType,

            NameProperty => nameType,
            StringProperty => stringType,
            TextProperty => textType,

            StructProperty structProperty => ExportStruct(structProperty),

            ObjectPropertyBase objectPropertyBase => objectPropertyBase switch
            {
                ObjectProperty => unrealObjectType,

                WeakObjectProperty => sg.QualifiedName(publicNamespace, sg.GenericName(nameof(WeakObjectReference<Object>), ExportClass(objectPropertyBase.PropertyClass))),
                LazyObjectProperty => sg.QualifiedName(publicNamespace, sg.GenericName(nameof(LazyObjectReference<Object>), ExportClass(objectPropertyBase.PropertyClass))),
                SoftObjectProperty => sg.QualifiedName(publicNamespace, sg.GenericName(nameof(SoftObjectReference<Object>), ExportClass(objectPropertyBase.PropertyClass))),

                _ => throw new NotImplementedException(),
            },

            InterfaceProperty interfaceProperty => ExportInterface(interfaceProperty.InterfaceClass),

            ArrayProperty arrayProperty => sg.QualifiedName(publicNamespace, sg.GenericName(nameof(Array<nint>), GetPropertyType(arrayProperty.ItemProperty))),
            MapProperty mapProperty => sg.QualifiedName(publicNamespace, sg.GenericName(nameof(Map<nint, nint>), GetPropertyType(mapProperty.KeyProperty), GetPropertyType(mapProperty.ValueProperty))),
            SetProperty setProperty => sg.QualifiedName(publicNamespace, sg.GenericName(nameof(Set<nint>), GetPropertyType(setProperty.ItemProperty))),

            DelegateProperty delegateProperty => ExportDelegate(delegateProperty.SignatureMethod),

            MulticastDelegateProperty multicastDelegateProperty => multicastDelegateProperty switch
            {
                MulticastInlineDelegateProperty multicastInlineDelegateProperty => ExportMulticastDelegate(multicastInlineDelegateProperty.SignatureMethod),
                MulticastSparseDelegateProperty => null!,
                _ => throw new NotImplementedException(),
            },

            PropertyPathProperty => null!,

            _ => throw new NotImplementedException(),
        };

        [UnmanagedCallersOnly]
        internal static void Initialize()
        {
            using AdhocWorkspace workspace = new AdhocWorkspace();

            sg = SyntaxGenerator.GetGenerator(workspace, LanguageNames.CSharp);

            sbyteType = SF.PredefinedType(SF.Token(SyntaxKind.SByteKeyword));
            byteType = SF.PredefinedType(SF.Token(SyntaxKind.ByteKeyword));
            int16Type = SF.PredefinedType(SF.Token(SyntaxKind.ShortKeyword));
            uint16Type = SF.PredefinedType(SF.Token(SyntaxKind.UShortKeyword));
            int32Type = SF.PredefinedType(SF.Token(SyntaxKind.IntKeyword));
            uint32Type = SF.PredefinedType(SF.Token(SyntaxKind.UIntKeyword));
            int64Type = SF.PredefinedType(SF.Token(SyntaxKind.LongKeyword));
            uint64Type = SF.PredefinedType(SF.Token(SyntaxKind.ULongKeyword));
            singleType = SF.PredefinedType(SF.Token(SyntaxKind.FloatKeyword));
            doubleType = SF.PredefinedType(SF.Token(SyntaxKind.DoubleKeyword));
            stringType = SF.PredefinedType(SF.Token(SyntaxKind.StringKeyword));
            nintType = sg.IdentifierName("nint");

            bytePointerType = SF.PointerType(byteType);

            globalNamespace = SF.IdentifierName(SF.Token(SyntaxKind.GlobalKeyword));
            internalNamespace = sg.QualifiedName(SF.AliasQualifiedName(globalNamespace, (IdentifierNameSyntax)sg.IdentifierName(nameof(NextTurn))), sg.IdentifierName(nameof(UE)));
            publicNamespace = SF.AliasQualifiedName(globalNamespace, (IdentifierNameSyntax)sg.IdentifierName(nameof(Unreal)));

            nativeBooleanType = sg.QualifiedName(internalNamespace, sg.IdentifierName(nameof(NativeBoolean)));

            nameType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Name)));
            textType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Text)));

            unrealObjectType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Object)));
            unrealClassType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Class)));
            unrealStructType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Struct)));
            unrealPropertyType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Property)));
            unrealMethodType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Method)));
            scriptDelegateType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(ScriptDelegate)));
            idynamicDelegateType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(IDynamicDelegate)));
            dynamicMulticastDelegateType = sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(DynamicMulticastDelegate)));

            booleanMarshalerType = sg.QualifiedName(internalNamespace, sg.IdentifierName(nameof(BooleanMarshaler)));
            objectMarshalerType = sg.QualifiedName(internalNamespace, sg.IdentifierName(nameof(ObjectMarshaler)));
            stringMarshalerType = sg.QualifiedName(internalNamespace, sg.IdentifierName(nameof(StringMarshaler)));
            textMarshalerType = sg.QualifiedName(internalNamespace, sg.IdentifierName(nameof(TextMarshaler)));

            packageAnyProperty = sg.QualifiedName(sg.QualifiedName(publicNamespace, sg.IdentifierName(nameof(Package))), sg.IdentifierName(nameof(Package.Any)));

            objectFindClassMethod = sg.QualifiedName(unrealObjectType, sg.GenericName(nameof(Object.Find), unrealClassType));
            booleanMarshalerToManagedMethod = sg.QualifiedName(booleanMarshalerType, sg.IdentifierName(nameof(BooleanMarshaler.ToManaged)));
            booleanMarshalerToNativeMethod = sg.QualifiedName(booleanMarshalerType, sg.IdentifierName(nameof(BooleanMarshaler.ToNative)));
            objectMarshalerToManagedMethod = sg.QualifiedName(objectMarshalerType, sg.IdentifierName(nameof(ObjectMarshaler.ToManaged)));
            objectMarshalerToNativeMethod = sg.QualifiedName(objectMarshalerType, sg.IdentifierName(nameof(ObjectMarshaler.ToNative)));
            stringMarshalerToManagedMethod = sg.QualifiedName(stringMarshalerType, sg.IdentifierName(nameof(StringMarshaler.ToManaged)));
            stringMarshalerToNativeMethod = sg.QualifiedName(stringMarshalerType, sg.IdentifierName(nameof(StringMarshaler.ToNative)));
            textMarshalerToManagedMethod = sg.QualifiedName(textMarshalerType, sg.IdentifierName(nameof(TextMarshaler.ToManaged)));
            textMarshalerToNativeMethod = sg.QualifiedName(textMarshalerType, sg.IdentifierName(nameof(TextMarshaler.ToNative)));

            declarations = new();

            classes = new();
            delegates = new();
            enums = new();
            interfaces = new();
            multicastDelegates = new();
            structs = new();
        }
    }
}
